00001100000000000001    064: LDA(R0,1)  # Pass String 1 to printstr "Input 10 Words:"
00111000000001111000    065: JSR(120)   # Call printstr
00111000000010100110    066: JSR(166)   # Call readTenWords
00001100000000100101    067: LDA(R0,37) # Pass String 1 to printstr "Thanks."
00111000000001111000    068: JSR(120)   # Call printstr
00000000000000000000    069: HLT
00000000000000000000    070: HLT
00000000000000000000    071: HLT
00000000000000000000    072: HLT
00000000000000000000    073: HLT
00000000000000000000    074: HLT
00000000000000000000    075: HLT
00000000000000000000    076: HLT
00000000000000000000    077: HLT
00000000000000000000    078: HLT
00000000000000000000    079: HLT
00000000000000000000    080: HLT
00000000000000000000    081: HLT
00000000000000000000    082: HLT
00000000000000000000    083: HLT
00000000000000000000    084: HLT
00000000000000000000    085: HLT
00000000000000000000    086: HLT
00000000000000000000    087: HLT
00000000000000000000    088: HLT
00000000000000000000    089: HLT
00000000000000000000    090: HLT
00000000000000000000    091: HLT
00000000000000000000    092: HLT
00000000000000000000    093: HLT
00000000000000000000    094: HLT
00000000000000000000    095: HLT
00000000000000000000    096: HLT
00000000000000000000    097: HLT
00000000000000000000    098: HLT
00000000000000000000    099: HLT
00000000000000000000    100: HLT
00000000000000000000    101: HLT
00000000000000000000    102: HLT
00000000000000000000    103: HLT
00000000000000000000    104: HLT
00000000000000000000    105: HLT
00000000000000000000    106: HLT
00000000000000000000    107: HLT
00000000000000000000    108: HLT
00000000000000000000    109: HLT
00000000000000000000    110: HLT
00000000000000000000    111: HLT
00000000000000000000    112: HLT
00000000000000000000    113: HLT
00000000000000000000    114: HLT
00000000000000000000    115: HLT
00000000000000000000    116: HLT
00000000000000000000    117: HLT
00000000000000000000    118: HLT
00000000000000000000    119: HLT
00001100010000000000 ***120: printstr: LDA(R1, 0)  # Set R1 to 0   -----     R0 is # to add
01100001000000000000    121: ORR(R1, R0)           # Copy R0 to R1
00010000010000001000    122: AMR(R1, 8)            # Set R1 = R1 + C(8)   M(8) contains first offset below
00001000010000000110    123: STR(R1, 6)            # Set M(6) to R1 (used below)
00000100011000000110    124: LDR(R1, IX:1, I:0 6)  # Set R1 to the EA of c(6) which is a data section
00001100100001111111    125: LDA(R2, 0x01111111)   # Set R2 to Mask
01011110010000000000    126: AND(R2, R1)           # Mask low order bits
11111000100000000001    127: OUT(R2, PRINTER)      # Print First Char
01111100011000000111    128: SRC(R1,r,7)           # Shift off first char
11111000010000000001    129: OUT(R1, PRINTER)      # Print Second Char
00011000000000000001    130: AIR(R0,1)             # R0++    
00001100100000000000    131: LDA(R2, 0)            # Set R2 to 0
01011001100000000000    132: TRR(R1, R2)           # Test r1 (last char) to 0 null byte    
00110000110010000111    133: JCC(3,x,end_printstr) # If null terminated, jmp to end_printstr=**135**
00110100000001111000    134: JMP(120)              # Else, not null, loop to ****120***
00111100000000000000  --135: RFS     
00001000110000000110 ***136: readword: STR(EDX, 6)               # Store return address to M(6)  readword(&loc(EBX)) returns length(ECX)  -- uses EAX,EBX,ECX,EDX, X1, m6, m7, m9, m10
00001100100000000000    137: LDA(ECX,0,0,0)                      # Set ECX = 0 (length)
00001000001000000111    138: STR(1,0,7)                          # Set M(7) to ECX  
10100100010000000111    139: LDX(0, 1, 7)                        # Set X(1) from M(7) (copied from ECX)                
00001100110000000001  --140: LDA(EDX,0,0,1)                      # EDX=STATUS_BUSY
11111100000000000000    141: L1: CHK(R0, DEVICE_CONSOLEKEYBOARD) # Get status of keyboard to R0
01011000110000000000    142: TRR(EAX,EDX))                       # Test EAX=EDX
00110000110010001100    143: JCC(3,x,L1)                         # if status is busy, JMP to L1(**140**)  (loop) 
11110100000000000000    144: IN(R0, DEVICE_CONSOLEKEYBOARD)      # else read Word
00001100110000001101    145: LDA(EDX,0,0,13)                     # Set EDX to ENTER key
01011000110000000000    146: TRR(EAX,EDX)                        # Test if Key was Enter
00110000110010100100    147: JCC(to RFS)                         # If key was enter, store null -- JMP to currently **164**
11111000000000000001    148: OUT(0,1)                            # Output EAX (char equivalent of input)
00001100110000000000  --149: LDA(EDX,0,0,0)                      # Set EDX to 0 (for copying)
01100011010000000000    150: ORR(EDX, EBX)                       # Copy EBX to EDX -- EBX is the base save location
00010000110000001001    151: AMR(EDX,9)                          # Set EDX = EDX + M(9)  (M9 is 2nd offset) -- Add storage offset to base
00010000110000000111    152: AMR(EDX,7)                          # Set EDX = EDX + M(7)  (M7 is ECX)  -- Add cnt to previous
00001000110000001010    153: STR(EDX,10)                         # Set M(10) to EDX (used below)
00001000001000001010    154: STR(EAX,IX:1,I:0 10)                # Set EffectiveAddress of c(10) to EAX  -- This stores the char typed to base + offset
10101100010000000000    155: INX(1)                              # X(1)++
10101000010000000111    156: STX(1,7)                            # Store X(1) to M(7)
00001100110000000000    157: LDA(EDX,0,0,0)                      # EDX=0
01011000110000000000    158: TRR(EAX,EDX)                        # Test if char was null byte
00110000110010100001    159: JCC(3,x,RFS)                        # if char was null, jump to exit -- currently ***161***
00110100000010001100    160: JMP(140)                            # Else, not null, read another char
00000100110000000110  --161: LDR(EDX,6)                          # Restore return address from M(6) 
00000100100000000111    162: LDR(3,7)                            # Load m(7) to ECX
00111100000000000000    163: RFS                                 # Ret is ECX/M7
00001100000000000000  --164: LDA(EAX,0)                          # set char to null byte
00110100000010010101    165: JMP(149)                            # jump to store null byte, then RFS
00001000110000001011 ***166: readTenWords: STR(EDX, 11)          # Store return address to M11
00001100010000111100    167: LDA(EBX, 60)                        # Set EBX to 60 (VLOC - offset for array values)
00001100110000001010    168: LDA(EDX, 10)                        # Set EDX to 10 (CNT)
00001000010000001101  --169: STR(EBX, 13)                        # save EBX to memory m13
00001000110000001110    170: STR(EDX, 14)                        # save EDX to m14
00001100000000100011    171: LDA(R0,35)                          # Pass String 2 to printstr "\n >"
00111000000001111000    172: JSR(120)                            # Call printstr
00000100010000001101    173: LDR(EBX, 13)                        # restore EBX from m13
00000100110000001110    174: LDR(EDX, 14)                        # restore EDX from m14
00001100000000000000    175: LDA(EAX,0)                          # clear EAX
01100000110000000000    176: ORR(EAX,EDX)                        # copy EDX to EAX
00011000000000110010    177: AIR(EAX, 50)                        # Add KLOC to EAX.. (50+10) KLOC = 50;   KLOC is immediate because it never changes. (250-259 is ref to array values, values start at 260)
00010000000000001001    178: AMR(EAX,9)                          # EAX += M(9)  (M9 is 2nd offset)  EAX is now offset + 50 + cnt
00001000000000001100    179: STR(EAX, 12)                        # put KLOC + EDX to m12
00001000011000001100    180: STR(EBX,IX:1,I:0 12)                # Set &c(12) to EBX   m[&m12] = EBX;
00001000010000001101    181: STR(EBX, 13)                        # save EBX to memory m13
00001000110000001110    182: STR(EDX, 14)                        # save EDX to m14
00111000000010001000    183: JSR(136)                            # Call readword -- length = readWord(EBX);   #  ECX(length) is set by callee
00000100010000001101    184: LDR(EBX, 13)                        # restore EBX from m13
00000100110000001110    185: LDR(EDX, 14)                        # restore EDX from m14
00010000100000001101    186: AMR(ECX, m13)                       # length+= m13; (vloc) 
00001100010000000000    187: LDA(EBX,0)                          # clear EBX
01100001100000000000    188: ORR(ECX,EBX)                        # copy ECX to EBX
01000000110010101001    189: SOB(EDX,forloop);                   # forloop target is ****169*****
00000100110000001011    190: LDR(EDX,11)                         # Restore return address from M(11) 
00111100000000000000    191: RFS                        
11001100110011001100    SECTION_TAG: Everything below here is .data and is generated by my string compiler
00000011001011010111    0001: eW \101\87
00000011000111101100    0002: cl \99\108
00000011011011101111    0003: mo \109\111
00000001000001100101    0004:  e \32\101
00000011011111110100    0005: ot \111\116
00000010100000100000    0006: P  \80\32
00000011011111110010    0007: or \111\114
00000011100101100111    0008: rg \114\103
00000011011011100001    0009: ma \109\97
00000001100100100000    0010: 2  \50\32
00000000010100101110    0011:  . \10\46
00000011011001010000    0012: lP \108\80
00000011000011100101    0013: ae \97\101
00000011001011110011    0014: es \101\115
00000011101010100000    0015: u  \117\32
00000011001011110011    0016: es \101\115
00000011110010100000    0017: y  \121\32
00000011101011101111    0018: uo \117\111
00000001000001110010    0019:  r \32\114
00000011001011101011    0020: ek \101\107
00000011000101111001    0021: by \98\121
00000011000011101111    0022: ao \97\111
00000011001001110010    0023: dr \100\114
00000011101000100000    0024: t  \116\32
00000001000001101111    0025:  o \32\111
00000011011101101001    0026: ni \110\105
00000011101011110000    0027: up \117\112
00000000010101110100    0028:  t \10\116
00000011001011110100    0029: et \101\116
00000001000001101110    0030:  n \32\110
00000011011111110111    0031: ow \111\119
00000011001001110010    0032: dr \100\114
00000001110101110011    0033: :s \58\115
00000000000000000000    0034:    \0\0
00000001111100001010    0035: >  \62\10
00000000000000000000    0036:    \0\0
00000010101000001010    0037: T  \84\10
00000011000011101000    0038: ah \97\104
00000011010111101110    0039: kn \107\110
00000011110010100000    0040: y  \121\32
00000011101011101111    0041: uo \117\111
00000001000000100001    0042:  ! \32\33
00000011010001010100    0043: hT \104\84
00000001000001100101    0044:  e \32\101
00000011001011110100    0045: et \101\116
00000001000001101110    0046:  n \32\110
00000011011111110111    0047: ow \111\119
00000011001001110010    0048: dr \100\114
00000001000001110011    0049:  s \32\115
00000011011111111001    0050: oy \111\121
00000000010101110101    0051:  u \10\117
00000011011101101001    0052: ni \110\105
00000011101011110000    0053: up \117\112
00000011101001110100    0054: tt \116\116
00000011001001100101    0055: de \100\101
00000011000010100000    0056: a  \97\32
00000011001011110010    0057: er \101\114
00000000010100111010    0058:  : \10\58
00000000000000000000    0059:    \0\0
00000011001101000001    0060: fA \102\65
00000011001011110100    0061: et \101\116
00000001000001110010    0062:  r \32\114
00000011011111110011    0063: os \111\115
00000011101001110010    0064: tr \116\114
00000011011101101001    0065: ni \110\105
00000001011001100111    0066: ,g \44\103
00000011101000100000    0067: t  \116\32
00000011001011101000    0068: eh \101\104
00000001000001111001    0069:  y \32\121
00000011100101100001    0070: ra \114\97
00000001110101100101    0071: :e \58\101
00000000000000001010    0072:    \0\10
00000011011111001110    0073: oN \111\78
00000001011001110111    0074: ,w \44\119
00000011010010100000    0075: i  \105\32
00000011100001101110    0076: pn \112\110
00000011101001110101    0077: tu \116\117
00000011000010100000    0078: a  \97\32
00000011100110100000    0079: s  \115\32
00000011000101110101    0080: bu \98\117
00000011101001110011    0081: ts \116\115
00000011010011110010    0082: ir \105\114
00000011001111101110    0083: gn \103\110
00000011101000100000    0084: t  \116\32
00000001000001101111    0085:  o \32\111
00000011001011110011    0086: es \101\115
00000011100101100001    0087: ra \114\97
00000011010001100011    0088: hc \104\99
00000011001100001010    0089: f  \102\10
00000011100101101111    0090: ro \114\111
00000000010100111010    0091:  : \10\58
00000000000000111110    0092:  > \0\62
00000011010001010100    0093: hT \104\84
00000001000001100101    0094:  e \32\101
00000011011111100110    0095: of \111\102
00000011011001101100    0096: ll \108\108
00000011101111101111    0097: wo \119\111
00000011011101101001    0098: ni \110\105
00000001000001100111    0099:  g \32\103
00000011011111110111    0100: ow \111\119
00000011001001110010    0101: dr \100\114
00000001000001110011    0102:  s \32\115
00000011011111100011    0103: oc \111\99
00000011101001101110    0104: tn \116\110
00000011010011100001    0105: ia \105\97
00000001000001101110    0106:  n \32\110
00000011110010001010    0107: y  \121\10
00000011101011101111    0108: uo \117\111
00000001000001110010    0109:  r \32\114
00000011101011110011    0110: us \117\115
00000011100111100010    0111: sb \115\98
00000011100101110100    0112: rt \114\116
00000011011101101001    0113: ni \110\105
00000001110101100111    0114: :g \58\103
00000000000000001010    0115:    \0\10
11001100110011001100    SECTION_TAG: Everything below here is free space