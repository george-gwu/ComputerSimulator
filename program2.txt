00001100000000000001    064: LDA(R0,1)  # Pass String 1 to printstr "Input 10 Words:"
00111000000001111000    065: JSR(120)   # Call printstr
00111000000010001000    066: JSR(136)   # Call readword
00001100000000100110    067: LDA(R0,38) # Pass String 1 to printstr "Thanks."
00111000000001111000    068: JSR(120)   # Call printstr
00000000000000000000    069: HLT
00000000000000000000    070: HLT
00000000000000000000    071: HLT
00000000000000000000    072: HLT
00000000000000000000    073: HLT
00000000000000000000    074: HLT
00000000000000000000    075: HLT
00000000000000000000    076: HLT
00000000000000000000    077: HLT
00000000000000000000    078: HLT
00000000000000000000    079: HLT
00000000000000000000    080: HLT
00000000000000000000    081: HLT
00000000000000000000    082: HLT
00000000000000000000    083: HLT
00000000000000000000    084: HLT
00000000000000000000    085: HLT
00000000000000000000    086: HLT
00000000000000000000    087: HLT
00000000000000000000    088: HLT
00000000000000000000    089: HLT
00000000000000000000    090: HLT
00000000000000000000    091: HLT
00000000000000000000    092: HLT
00000000000000000000    093: HLT
00000000000000000000    094: HLT
00000000000000000000    095: HLT
00000000000000000000    096: HLT
00000000000000000000    097: HLT
00000000000000000000    098: HLT
00000000000000000000    099: HLT
00000000000000000000    100: HLT
00000000000000000000    101: HLT
00000000000000000000    102: HLT
00000000000000000000    103: HLT
00000000000000000000    104: HLT
00000000000000000000    105: HLT
00000000000000000000    106: HLT
00000000000000000000    107: HLT
00000000000000000000    108: HLT
00000000000000000000    109: HLT
00000000000000000000    110: HLT
00000000000000000000    111: HLT
00000000000000000000    112: HLT
00000000000000000000    113: HLT
00000000000000000000    114: HLT
00000000000000000000    115: HLT
00000000000000000000    116: HLT
00000000000000000000    117: HLT
00000000000000000000    118: HLT
00000000000000000000    119: HLT
00001100010000000000 ***120: printstr: LDA(R1, 0)  # Set R1 to 0   -----     R0 is # to add
01100001000000000000    121: ORR(R1, R0)           # Copy R0 to R1
00010000010000001000    122: AMR(R1, 8)            # Set R1 = R1 + C(8)   M(8) contains first offset below
00001000010000000110    123: STR(R1, 6)            # Set M(6) to R1 (used below)
00000100011000000110    124: LDR(R1, IX:1, I:0 6)  # Set R1 to the EA of c(6) which is a data section
00001100100001111111    125: LDA(R2, 0x01111111)   # Set R2 to Mask
01011110010000000000    126: AND(R2, R1)           # Mask low order bits
11111000100000000001    127: OUT(R2, PRINTER)      # Print First Char
01111100011000000111    128: SRC(R1,r,7)           # Shift off first char
11111000010000000001    129: OUT(R1, PRINTER)      # Print Second Char
00011000000000000001    130: AIR(R0,1)             # R0++    
00001100100000000000    131: LDA(R2, 0)            # Set R2 to 0
01011001100000000000    132: TRR(R1, R2)           # Test r1 (last char) to 0 null byte    
00110000110010000111    133: JCC(3,x,end_printstr) # If null terminated, jmp to end_printstr=**135**
00110100000001111000    134: JMP(120)              # Else, not null, loop to ****120***
00111100000000000000  --135: RFS     
00001000110000000110 ***136: readword: STR(EDX, 6)               # Store return address to M(6)
00001100100000000000    137: LDA(ECX,0,0,0)                      # Set ECX = 0 (length)
00001000001000000111    138: STR(1,0,7)                          # Set M(7) to ECX  
10100100010000000111    139: LDX(0, 1, 7)                        # Set X(1) from M(7) (copied from ECX)                
00001100110000000001  --140: LDA(EDX,0,0,1)                      # EDX=STATUS_BUSY
11111100000000000000    141: L1: CHK(R0, DEVICE_CONSOLEKEYBOARD) # Get status of keyboard to R0
01011000110000000000    142: TRR(EAX,EDX))                       # Test EAX=EDX
00110000110010001100    143: JCC(3,x,L1)                         # if status is busy, JMP to L1(**140**)  (loop) 
11110100000000000000    144: IN(R0, DEVICE_CONSOLEKEYBOARD)      # else read Word
00001100110000001101    145: LDA(EDX,0,0,13)                     # Set EDX to ENTER key
01011000110000000000    146: TRR(EAX,EDX)                        # Test if Key was Enter
00110000110010100100    147: JCC(to RFS)                         # If key was enter, store null -- JMP to currently **164**
11111000000000000001    148: OUT(0,1)                            # Output EAX (char equivalent of input)
00001100110000000000  --149: LDA(EDX,0,0,0)                      # Set EDX to 0 (for copying)
01100011010000000000    150: ORR(EDX, EBX)                       # Copy EBX to EDX -- EBX is the base save location
00010000110000001001    151: AMR(EDX,9)                          # Set EDX = EDX + M(9)  (M9 is 2nd offset) -- Add storage offset to base
00010000110000000111    152: AMR(EDX,7)                          # Set EDX = EDX + M(7)  (M7 is ECX)  -- Add cnt to previous
00001000110000001010    153: STR(EDX,10)                         # Set M(10) to EDX (used below)
00001000001000001010    154: STR(EAX,IX:1,I:0 10)                # Set EffectiveAddress of c(10) to EAX  -- This stores the char typed to base + offset
10101100010000000000    155: INX(1)                              # X(1)++
10101000010000000111    156: STX(1,7)                            # Store X(1) to M(7)
00001100110000000000    157: LDA(EDX,0,0,0)                      # EDX=0
01011000110000000000    158: TRR(EAX,EDX)                        # Test if char was null byte
00110000110010100001    159: JCC(3,x,RFS)                        # if char was null, jump to exit -- currently ***161***
00110100000010001100    160: JMP(140)                            # Else, not null, read another char
00000100110000000110  --161: LDR(EDX,6)                          # Restore return address from M(6) 
00000100100000000111    162: LDR(3,7)                            # Load m(7) to ECX
00111100000000000000    163: RFS              # Ret is ECX/M7
00001100000000000000  --164: LDA(EAX,0)                          # set char to null byte
00110100000010010101    165: JMP(149)                            # jump to store null byte, then RFS
11001100110011001100    SECTION_TAG: Everything below here is .data and is generated by my string compiler
00000011001011010111    0001: eW \101\87
00000011000111101100    0002: cl \99\108
00000011011011101111    0003: mo \109\111
00000001000001100101    0004:  e \32\101
00000011011111110100    0005: ot \111\116
00000010100000100000    0006: P  \80\32
00000011011111110010    0007: or \111\114
00000011100101100111    0008: rg \114\103
00000011011011100001    0009: ma \109\97
00000001100100100000    0010: 2  \50\32
00000000010100101110    0011:  . \10\46
00000011011001010000    0012: lP \108\80
00000011000011100101    0013: ae \97\101
00000011001011110011    0014: es \101\115
00000011101010100000    0015: u  \117\32
00000011001011110011    0016: es \101\115
00000011110010100000    0017: y  \121\32
00000011101011101111    0018: uo \117\111
00000001000001110010    0019:  r \32\114
00000011001011101011    0020: ek \101\107
00000011000101111001    0021: by \98\121
00000011000011101111    0022: ao \97\111
00000011001001110010    0023: dr \100\114
00000011101000100000    0024: t  \116\32
00000001000001101111    0025:  o \32\111
00000011011101101001    0026: ni \110\105
00000011101011110000    0027: up \117\112
00000000010101110100    0028:  t \10\116
00000011001011110100    0029: et \101\116
00000001000001101110    0030:  n \32\110
00000011011111110111    0031: ow \111\119
00000011001001110010    0032: dr \100\114
00000001110101110011    0033: :s \58\115
00000001111100001010    0034: >  \62\10
00000000000000000000    0035:    \0\0
00000001111100001010    0036: >  \62\10
00000000000000000000    0037:    \0\0
00000010101000001010    0038: T  \84\10
00000011000011101000    0039: ah \97\104
00000011010111101110    0040: kn \107\110
00000011110010100000    0041: y  \121\32
00000011101011101111    0042: uo \117\111
00000001000000100001    0043:  ! \32\33
00000011010001010100    0044: hT \104\84
00000001000001100101    0045:  e \32\101
00000011001011110100    0046: et \101\116
00000001000001101110    0047:  n \32\110
00000011011111110111    0048: ow \111\119
00000011001001110010    0049: dr \100\114
00000001000001110011    0050:  s \32\115
00000011011111111001    0051: oy \111\121
00000000010101110101    0052:  u \10\117
00000011011101101001    0053: ni \110\105
00000011101011110000    0054: up \117\112
00000011101001110100    0055: tt \116\116
00000011001001100101    0056: de \100\101
00000011000010100000    0057: a  \97\32
00000011001011110010    0058: er \101\114
00000000010100111010    0059:  : \10\58
00000000000000000000    0060:    \0\0
00000011001101000001    0061: fA \102\65
00000011001011110100    0062: et \101\116
00000001000001110010    0063:  r \32\114
00000011011111110011    0064: os \111\115
00000011101001110010    0065: tr \116\114
00000011011101101001    0066: ni \110\105
00000001011001100111    0067: ,g \44\103
00000011101000100000    0068: t  \116\32
00000011001011101000    0069: eh \101\104
00000001000001111001    0070:  y \32\121
00000011100101100001    0071: ra \114\97
00000001110101100101    0072: :e \58\101
00000000000000001010    0073:    \0\10
00000011011111001110    0074: oN \111\78
00000001011001110111    0075: ,w \44\119
00000011010010100000    0076: i  \105\32
00000011100001101110    0077: pn \112\110
00000011101001110101    0078: tu \116\117
00000011000010100000    0079: a  \97\32
00000011100110100000    0080: s  \115\32
00000011000101110101    0081: bu \98\117
00000011101001110011    0082: ts \116\115
00000011010011110010    0083: ir \105\114
00000011001111101110    0084: gn \103\110
00000011101000100000    0085: t  \116\32
00000001000001101111    0086:  o \32\111
00000011001011110011    0087: es \101\115
00000011100101100001    0088: ra \114\97
00000011010001100011    0089: hc \104\99
00000011001100001010    0090: f  \102\10
00000011100101101111    0091: ro \114\111
00000000010100111010    0092:  : \10\58
00000000000000111110    0093:  > \0\62
00000011010001010100    0094: hT \104\84
00000001000001100101    0095:  e \32\101
00000011011111100110    0096: of \111\102
00000011011001101100    0097: ll \108\108
00000011101111101111    0098: wo \119\111
00000011011101101001    0099: ni \110\105
00000001000001100111    0100:  g \32\103
00000011011111110111    0101: ow \111\119
00000011001001110010    0102: dr \100\114
00000001000001110011    0103:  s \32\115
00000011011111100011    0104: oc \111\99
00000011101001101110    0105: tn \116\110
00000011010011100001    0106: ia \105\97
00000001000001101110    0107:  n \32\110
00000011110010001010    0108: y  \121\10
00000011101011101111    0109: uo \117\111
00000001000001110010    0110:  r \32\114
00000011101011110011    0111: us \117\115
00000011100111100010    0112: sb \115\98
00000011100101110100    0113: rt \114\116
00000011011101101001    0114: ni \110\105
00000001110101100111    0115: :g \58\103
00000000000000001010    0116:    \0\10
11001100110011001100    SECTION_TAG: Everything below here is free space