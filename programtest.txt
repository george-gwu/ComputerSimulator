00011000000000000000    64: AIR(R0,0)  # NOOP
00001100000000000001   *65: LDA(R0,1)  # Pass String 1 to printstr
00111000000001100100    66: JSR(100)   # Call printstr
00001100100000000100    67: LDA(R3,20) # Pass 20 (10100) to ECX    *** SET TO 4 for testing ****
00001000100000000111  --68: STR(2,0,7) # Set M(7) to ECX  (used in LDX below)  
10100100110000000111    69: LDX(0,3,7) # Set X(3) from M(7) (copied from ECX above, used in SOB loop)  
00001100000000100111    70: LDA(R0,39) # Pass String 2 (39) to PrintStr
00111000000001100100   *71: JSR(100)   # Call printstr  (uses EAX,EBX,ECX)
00111000000001110100    72: JSR(116)   # Call readnum, returns via EBX
10101000110000000111    73: STX(3,7)   # Store X(3) to M(7)
00000100100000000111    74: LDR(3,7)   # Load m(7) to ECX (used in SOB)
00000100000000000111    75: LDR(0,7)   # Load m(7) to EAX (used in saving value to memory)
00010000000000001001    76: AMR(EAX,9) # Set EAX = EAX + C(9)  M(9) contains 2nd offset below
00001000000000000110    77: STR(EAX,6) # Set M(6) to EAX (used below)
00001000011000000110    78: STR(EBX,IX:1,I:0 6) # Set EA of c(6) which is a storage space to EBX (ret from readnum)
01000000100001000100    79: SOB(3, 68) # Decrement ECX and JMP back (which holds it in X(3)) JMP to ***68***
00001100000000101001    80: LDA(R0,41) # Pass String 2 to printstr
00001100010000000000    81: LDA(EBX,00) # Set EBX to 0
01100101000000000000    82: NOT(EBX)    # Set EBX to all 1s
01111100011000000001    83: SRC(1,1,0,1)# Shift EBX right by 1 (EBX=MAX_INT)
00001000010000011101    84: STR(EBX,29) # Store MAX_INT to M(29) which holds the current min distance (used in testnum)
00111000000001100100   *85: JSR(100)    # Call printstr     
00111000000001110100    86: JSR(116)    # Call readnum, returns via EBX
00001000010000000111    87: STR(1,0,7)  # Set M(7) to EBX   M(7) is now the search number
00001100100000000100    88: LDA(R3,20)  # Pass 20 (10100) to ECX  (n)  *** SET TO 4 for testing ****
00111000000010001101    89: JSR(141)   # Call findclosest(ECX=cnt,EBX=search) ret to m30  ***141***
00000000000000000000    92: NOOP
00001100000001001100    90: LDA(R0,76) # Pass String 76 to printstr
00111000000001100100   *91: JSR(100)   # Call printstr
00000100000000011110    93: LDR(EAX,30)                  # Restore diff from M(30)
00010000000000001001    94: AMR(EAX,9)                   # Set EAX = EAX + C(9) (EAX is now address of winning digit)
00001000000000000110    95: STR(EAX,6)                   # Set M(6) to EAX (Store EAX to M6 for loading value next)
00000100001000000110    96: LDR(EAX,IX:1,I:0 6)          # Load EAX with c(6) which is the n value from the array 
00111000000010000111   *97: JSR(135)                     # Call printnum(EAX)
00000000000000000000    98: HLT
00000000000000000000    99: HLT
00001100010000000000 ***100: printstr: LDA(R1, 0)  # Set R1 to 0   -----     R0 is # to add
01100001000000000000    101: ORR(R1, R0)           # Copy R0 to R1
00010000010000001000    102: AMR(R1, 8)            # Set R1 = R1 + C(8)   M(8) contains first offset below
00001000010000000110    103: STR(R1, 6)            # Set M(6) to R1 (used below)
00000100011000000110    104: LDR(R1, IX:1, I:0 6)  # Set R1 to the EA of c(6) which is a data section
00001100100001111111    105: LDA(R2, 0x01111111)   # Set R2 to Mask
01011110010000000000    106: AND(R2, R1)           # Mask low order bits
11111000100000000001    107: OUT(R2, PRINTER)      # Print First Char
01111100011000000111    108: SRC(R1,r,7)           # Shift off first char
11111000010000000001    109: OUT(R1, PRINTER)      # Print Second Char
00011000000000000001    110: AIR(R0,1)             # R0++    
00001100100000000000    111: LDA(R2, 0)            # Set R2 to 0
01011001100000000000    112: TRR(R1, R2)           # Test r1 (last char) to 0 null byte    
00110000110001110011    113: JCC(3,x,end_printstr) # If null terminated, jmp to end_printstr=**115**
00110100000001100100    114: JMP(100)              # Else, not null, loop
00111100000000000000  --115: RFS                   
00001100010000000000 ***116: readnum: LDA(EBX,0,0,0)             # Clear EBX
00001100100000000001    117: LDA(ECX,0,0,1)                      # ECX=STATUS_BUSY
11111100000000000000  --118: L1: CHK(R0, DEVICE_CONSOLEKEYBOARD) # Get status of keyboard to R0
01011000100000000000    119: TRR(R0, R3))                        # Test EAX=ECX
00110000110001110110    120: JCC(3,x,L1)                         # if R0==R3, JMP to L1(**118**)  (loop) 
11110100000000000000    121: IN(R0, DEVICE_CONSOLEKEYBOARD)      # else read Word
00001100100000001101    122: LDA(ECX,0,0,13)                     # Set ECX to ENTER key
01011000100000000000    123: TRR(EAX,ECX)                        # Test if Key was Enter
00110000110010000110    124: JCC(to RFS)                         # If key was enter ---RFS---  --currently **134**
11111000000000000001    125: OUT(0,1)                            # Output EAX (char equivalent of input)
00011100000000110000    126: SIR(R0, 48)                         # Convert keycode to int
00001100100000001010    127: LDA(ECX,10)                         # Set ECX=10
01010001100000000000    128: MLT(EBX,ECX)                        # EBX*=10  (ECX)
00001000100000000110    129: STR(ECX, 6)                         # Set M(6) to ECX (low order bits of MLT) 
00010000000000000110    130: AMR(EAX, 6)                         # Add M(6) to EAX
00001100010000000000    131: LDA(R1, 0)                          # Clear EBX
01100001000000000000    132: ORR(R1, R0)                         # Copy R0 to R1
00110100000001110101    133: JMP(117)                            # Loop
00111100000000000000  --134: RFS
00001100010000001010 ***135: printnum: LDA(EBX,10)  # Set EBX=10;  EAX is num to print
01010100010000000000    136: DVD(EAX,EBX)           # loopdiv: EAX = quotient, EBX=remainder
00011000010000110000    137: AIR(EBX,48)            # Convert EBX from int to keycode
11111000010000000001    138: OUT(EBX,PRINTER)       # Print remainder
00101100000010000111    139: JNE(EAX,loopdiv)       # If quotient>0, more digits to go loopdiv=135
00111100000000000000  --140: RFS
00001100000000000000 ***141: findclosest: LDA(R0, 0)      # Clear EAX    findclosest(ECX=cnt,EBX=search,m29=MAX_INT)
01100000100000000000    142: ORR(EAX,ECX)                 # Copy ECX to EAX (n)
00010000000000001001    143: AMR(EAX,9)                   # Set EAX = EAX + C(9) (EAX is now addr of digit n--n+2nd_offset)
00001000000000000110    144: STR(EAX,6)                   # Set M(6) to EAX (Store EAX to M6 for loading value next)
00000100001000000110    145: LDR(EAX,IX:1,I:0 6)          # Load EAX with c(6) which is the n value from the array 
00010100000000000111    146: SMR(EAX,7)                   # Subtract current(EAX)-SEARCH(m7), EAX=diff
01000100000010010110    147: JGE(EAX, testdiff)           # if EAX>=0, jump to ****150***
00000100000000000111    148: LDR(EAX,7)                   # else, flip operands and diff again - Set EAX = SEARCH
00010100001000000110    149: SMR(EAX,IX:1,I:0 6)          # Subtract search(EAX)-current(m6), EAX=diff
00001000000000011111  --150: testdiff: STR(EAX,31)        # Store diff(EAX) to m31
00000100000000011101    151: LDR(EAX,29)                  # Load current min to EAX
00010100000000011111    152: SMR(EAX,31)                  # Subtract current min(3/eax) - diff(5/m31)     9999999 - 5
01000100000010011100    153: JGE(EAX,finish)              # Diff is the new min, jmp to finish = ****156****
01000000100010001101    154: SOB(3,findclosest)           # Diff is not the new min; Decrement ECX and JMP back -- JMP to ***141***
00111100000000000000    155: RFS                          # if was last, return
00001000100000011110  --156: finish: STR(ECX,30)          # Store current index to current winner index
00000100000000011111    157: LDR(EAX,31)                  # Restore diff from M(31)
00001000000000011101    158: STR(EAX,29)                  # Store new diff to m29 (new low diff)
01000000100010001101    159: SOB(3,findclosest)           # Decrement ECX and JMP back -- JMP to ***141***
00111100000000000000  --160: RFS
11001100110011001100    SECTION_TAG: Everything below here is .data and is generated by my string compiler
00000011001011010111    0001: eW \101\87
00000011000111101100    0002: cl \99\108
00000011011011101111    0003: mo \109\111
00000001000001100101    0004:  e \32\101
00000011011111110100    0005: ot \111\116
00000010100000100000    0006: P  \80\32
00000011011111110010    0007: or \111\114
00000011100101100111    0008: rg \114\103
00000011011011100001    0009: ma \109\97
00000001100010100000    0010: 1  \49\32
00000000010100101110    0011:  . \10\46
00000011011001010000    0012: lP \108\80
00000011000011100101    0013: ae \97\101
00000011001011110011    0014: es \101\115
00000011101010100000    0015: u  \117\32
00000011001011110011    0016: es \101\115
00000011101000100000    0017: t  \116\32
00000011001011101000    0018: eh \101\104
00000011101100100000    0019: v  \118\32
00000011100101101001    0020: ri \114\105
00000011101011110100    0021: ut \117\116
00000011011001100001    0022: la \108\97
00000011010110100000    0023: k  \107\32
00000011110011100101    0024: ye \121\101
00000011000011110000    0025: ap \97\112
00000001000001100100    0026:  d \32\100
00000011011111110100    0027: ot \111\116
00000000010100100000    0028:    \10\32
00000011011101101001    0029: ni \110\105
00000011101011110000    0030: up \117\112
00000001000001110100    0031:  t \32\116
00000001100000110010    0032: 02 \48\50
00000011011100100000    0033: n  \110\32
00000011011011110101    0034: mu \109\117
00000011001011100010    0035: eb \101\98
00000011100111110010    0036: sr \115\114
00000000010100101110    0037:  . \10\46
00000000000000000000    0038:    \0\0
00000001111100001010    0039: >  \62\10
00000000000000000000    0040:    \0\0
00000010101000001010    0041: T  \84\10
00000011000011101000    0042: ah \97\104
00000011010111101110    0043: kn \107\110
00000011110010100000    0044: y  \121\32
00000011101011101111    0045: uo \117\111
00000000010100100001    0046:  ! \10\33
00000011011111001110    0047: oN \111\78
00000001000001110111    0048:  w \32\119
00000011011001110000    0049: lp \108\112
00000011000011100101    0050: ae \97\101
00000011001011110011    0051: es \101\115
00000011001010100000    0052: e  \101\32
00000011101001101110    0053: tn \116\110
00000011100101100101    0054: re \114\101
00000011011110100000    0055: o  \111\32
00000011001011101110    0056: en \101\110
00000011000010100000    0057: a  \97\32
00000011001001100100    0058: dd \100\100
00000011101001101001    0059: ti \116\105
00000011011111101001    0060: oi \111\105
00000011000011101110    0061: an \97\110
00000000010101101100    0062:  l \10\108
00000011101011101110    0063: un \117\110
00000011000101101101    0064: bm \98\109
00000011100101100101    0065: re \114\101
00000011101000100000    0066: t  \116\32
00000001000001101111    0067:  o \32\111
00000011001011110011    0068: es \101\115
00000011100101100001    0069: ra \114\97
00000011010001100011    0070: hc \104\99
00000011001100100000    0071: f  \102\32
00000011100101101111    0072: ro \114\111
00000000010100111010    0073:  : \10\58
00000001111100001010    0074: >  \62\10
00000000000000000000    0075:    \0\0
00000010101000001010    0076: T  \84\10
00000011001011101000    0077: eh \101\104
00000011000110100000    0078: c  \99\32
00000011011111101100    0079: ol \111\108
00000011001011110011    0080: es \101\115
00000011101001110011    0081: ts \116\115
00000011011100100000    0082: n  \110\32
00000011011011110101    0083: mu \109\117
00000011001011100010    0084: eb \101\98
00000001000001110010    0085:  r \32\114
00000011100111101001    0086: si \115\105
00000001000000111010    0087:  : \32\58
00000000000000000000    0088:    \0\0
11001100110011001100    SECTION_TAG: Everything below here is free space