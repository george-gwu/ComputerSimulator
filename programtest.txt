00000000000000000000    64: HLT
00001100000000000001    65: LDA(R0,1)  // Pass String 1 to PrintStr
00111000000001100100    66: JSR(100)   R3=RET   // Call printstr     
00001100100000010100    67: LDA(R3,20)  // Pass 20 (10100) to ECX    *** SET TO 4 for testing ****
00001000100000000111  --68: STR(2,0,7)  -- set M(7) to ECX  (used in LDX below)  
10100100110000000111    69: LDX(0,3,7)   -- Set X(3) from M(7) (copied from ECX above, used in SOB loop)  
00001100000000100111    70: LDA(R0,39)  // Pass String 2 (39) to PrintStr
00111000000001100100    71: JSR(100)   R3=RET   // Call printstr     
00111000000001110100    72: JSR(116) // call readnum, returns via EBX
10101000110000000111    73: STX(3,7) -- Store X(3) to M(7)
00000100100000000111    74: LDR(3,7) -- Load m(7) to ECX (used in SOB)
00000100000000000111    75: LDR(0,7) -- Load m(7) to EAX (used in saving value to memory)
00010000000000001001    76: AMR(EAX, 9)  // set EAX = EAX + C(9)  M(9) contains 2nd offset below
00001000000000000110    77: STR(EAX, 6)  // set M(6) to EAX (used below)
00001000011000000110    78: STR(EBX, IX:1, I:0 6) // set EA of c(6) which is a storage space to EBX (ret from readnum)
01000000100001000100    79: SOB(3, loc****68*****)  -- Decrement ECX and JMP back (which holds it in X(3))
00000000000000000000    80: HLT
00000000000000000000    81: HLT
00000000000000000000    82: HLT
00000000000000000000    83: HLT
00000000000000000000    84: HLT
00000000000000000000    85: HLT
00000000000000000000    86: HLT
00000000000000000000    87: HLT
00000000000000000000    88: HLT
00000000000000000000    89: HLT
00000000000000000000    90: HLT
00000000000000000000    91: HLT
00000000000000000000    92: HLT
00000000000000000000    93: HLT
00000000000000000000    94: HLT
00000000000000000000    95: HLT
00000000000000000000    96: HLT
00000000000000000000    97: HLT
00000000000000000000    98: HLT
00000000000000000000    99: HLT
00001100010000000000 ***100: printstr: LDA(R1, 0)  /// set R1 to 0   -----     R0 is # to add
01100001000000000000    101: ORR(R1, R0)  // copy R0 to R1
00010000010000001000    102: AMR(R1, 8)  // set R1 = R1 + C(8)   M(8) contains first offset below
00001000010000000110    103: STR(R1, 6)  // set M(6) to R1 (used below)
00000100011000000110    104: LDR(R1, IX:1, I:0 6) // set R1 to the EA of c(6) which is a data section
00001100100001111111    105: LDA(R2, 0x01111111)
01011110010000000000    106: AND(R2, R1)  Mask low order bits
11111000100000000001    107: OUT(R2, PRINTER) 
01111100011000000111    108: SRC(R1,r,7)
11111000010000000001    109: OUT(R1, PRINTER) 
00011000000000000001    110: AIR(R0,1) R0++
00001100100000000000    111: LDA(R2, 0)   set R2 to 0
01011001100000000000    112: TRR(R1, R2) test r1 (last char) to 0 null byte    
00110000110001110011    113: JCC(3,x,end_printstr)  end_printstr=115  // if null terminated, jmp to end (**115**)
00110100000001100100    114: JMP(100)  // else, not null, loop
00111100000000000000  --115: RFS
00001100010000000000 ***116: READNUM: LDA(EBX,0,0,0)  Clear EBX
00001100100000000001    117: LDA(ECX,0,0,1)  ECX=STATUS_BUSY
11111100000000000000  --118: L1: CHK(R0, DEVICE_CONSOLEKEYBOARD)    -- get status of keyboard to R0
01011000100000000000    119: TRR(R0, R3))   - Test EAX=ECX
00110000110001110110    120: JCC(3,x,L1)    - if R0==R3, JMP to L1(**118**)  (loop) 
11110100000000000000    121: IN(R0, DEVICE_CONSOLEKEYBOARD)  -- else read Word
00001100100000001101    122: LDA(ECX,0,0,13) // ENTER key
01011000100000000000    123: TRR(EAX,ECX)  // Test if Key was Enter
00110000110010000110    124: JCC(to RFS)       // Was enter---RFS--  --currently **134**
11111000000000000001    125: OUT(0,1)       - Output EAX (char equivalent of input)
00011100000000110000    126: SIR(R0, 48)   -- Convert keycode to int
00001100100000001010    127: LDA(ECX,10)
01010001100000000000    128: MLT(EBX,ECX)  EBX*=10
00001000100000000110    129: STR(ECX, 6)  // set M(6) to ECX (low order bits of MLT) 
00010000000000000110    130: AMR(EAX, 6) 
00001100010000000000    131: LDA(R1, 0)  /// clear EBX
01100001000000000000    132: ORR(R1, R0)  // copy R0 to R1
00110100000001110101    133: JMP(117) // loop
00111100000000000000  --134: RFS
11001100110011001100    SECTION_TAG: Everything below here is .data
00000011001011010111    0001: eW \101\87
00000011000111101100    0002: cl \99\108
00000011011011101111    0003: mo \109\111
00000001000001100101    0004:  e \32\101
00000011011111110100    0005: ot \111\116
00000010100000100000    0006: P  \80\32
00000011011111110010    0007: or \111\114
00000011100101100111    0008: rg \114\103
00000011011011100001    0009: ma \109\97
00000001100010100000    0010: 1  \49\32
00000000010100101110    0011:  . \10\46
00000011011001010000    0012: lP \108\80
00000011000011100101    0013: ae \97\101
00000011001011110011    0014: es \101\115
00000011101010100000    0015: u  \117\32
00000011001011110011    0016: es \101\115
00000011101000100000    0017: t  \116\32
00000011001011101000    0018: eh \101\104
00000011101100100000    0019: v  \118\32
00000011100101101001    0020: ri \114\105
00000011101011110100    0021: ut \117\116
00000011011001100001    0022: la \108\97
00000011010110100000    0023: k  \107\32
00000011110011100101    0024: ye \121\101
00000011000011110000    0025: ap \97\112
00000001000001100100    0026:  d \32\100
00000011011111110100    0027: ot \111\116
00000000010100100000    0028:    \10\32
00000011011101101001    0029: ni \110\105
00000011101011110000    0030: up \117\112
00000001000001110100    0031:  t \32\116
00000001100000110010    0032: 02 \48\50
00000011011100100000    0033: n  \110\32
00000011011011110101    0034: mu \109\117
00000011001011100010    0035: eb \101\98
00000011100111110010    0036: sr \115\114
00000000010100101110    0037:  . \10\46
00000000000000000000    0038:    \0\0
00000001111100001010    0039: >  \62\10
00000000000000000000    0040:    \0\0
00000011010001010100    0041: hT \104\84
00000011011101100001    0042: na \110\97
00000001000001101011    0043:  k \32\107
00000011011111111001    0044: oy \111\121
00000001000011110101    0045: !u \33\117
00000010011100001010    0046: N  \78\10
00000011101111101111    0047: wo \119\111
00000011100000100000    0048: p  \112\32
00000011001011101100    0049: el \101\108
00000011100111100001    0050: sa \115\97
00000001000001100101    0051:  e \32\101
00000011011101100101    0052: ne \110\101
00000011001011110100    0053: et \101\116
00000001000001110010    0054:  r \32\114
00000011011101101111    0055: no \110\111
00000001000001100101    0056:  e \32\101
00000011001001100001    0057: da \100\97
00000011010011100100    0058: id \105\100
00000011010011110100    0059: it \105\116
00000011011101101111    0060: no \110\111
00000011011001100001    0061: la \108\97
00000011011100100000    0062: n  \110\32
00000011011011110101    0063: mu \109\117
00000011001011100010    0064: eb \101\98
00000001000001110010    0065:  r \32\114
00000011011111110100    0066: ot \111\116
00000011100110100000    0067: s  \115\32
00000011000011100101    0068: ae \97\101
00000011000111110010    0069: cr \99\114
00000001000001101000    0070:  h \32\104
00000011011111100110    0071: of \111\102
00000001110101110010    0072: :r \58\114
00000001111100001010    0073: >  \62\10
00000000000000001010    0074:    \0\10
11001100110011001100    SECTION_TAG: Everything below here is free space